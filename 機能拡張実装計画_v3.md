# NoteFolder 機能拡張 実装計画（v3 - Codexレビュー済み）

## 引き継ぎ概要

**プロジェクトパス**: `/mnt/c/Users/littl/app-dev/06_NoteFolder/NoteFolder`

**現在の状態**: MVP完了済み、7つの新機能追加計画策定完了

**レビュー状況**: Codex MCPで3回レビュー済み、P0/P1問題なし

---

## 実装する機能（7つ）

| # | 機能 | 概要 | Phase |
|---|------|------|-------|
| 0 | **基盤整備** | スキーマ統一・キャッシュ拡張・マイグレーション | 0 |
| 1 | タグの階層化 | `/`区切り（例: "AI/機械学習"）で親子関係 | 1 |
| 2 | タグの色分け | タグごとに背景色を設定 | 1 |
| 3 | タグの使用統計 | 使用回数を遅延計算・表示 | 3 |
| 4 | タグの常時表示 | プロジェクト名横にバッジ表示（最大3個） | 2 |
| 5 | プロジェクト名検索 | 名前でリアルタイム検索 | 2 |
| 6 | タグなしプロジェクト表示 | 未分類プロジェクトをフィルター | 2 |
| 7 | お気に入り/ピン留め | ★で上部固定 | 2 |

---

## Codexレビュー指摘事項と対応

### 問題点の重要度分類（全て対応済み）

| 重要度 | 問題 | 対応 |
|--------|------|------|
| **P0** | マイグレーション戦略が不明確 | 具体的な移行手順・互換性レイヤーを定義 |
| **P0** | プロジェクト名が保存されていない | Phase 0で名前キャプチャ追加 |
| **P0** | tagMetaがキャッシュ対象外 | Phase 0でキャッシュ拡張 |
| **P1** | 既存タグにドット(.)が使用可能 | 区切り文字を`/`に変更 |
| **P1** | 名前キャプチャの詳細不明 | 取得タイミング・同期方法を定義 |
| **P1** | tagMetaの8KB制限問題 | シャーディング戦略を定義 |
| **P1** | 構造化フィルターの詳細不明 | データモデル・UI・削除伝播を定義 |
| **P1** | allTagsとtagMetaの重複 | tagMetaに統合、allTagsは導出 |
| **P2** | 512キー制限 | ガードレール追加 |
| **P2** | 書き込み制限 | 遅延計算方式に変更 |

---

## 新データ構造（統合版）

```javascript
{
  // プロジェクトデータ（拡張版）
  "project:{uuid}": {
    "id": "uuid",
    "name": "プロジェクト名",           // DOMから取得して保存
    "tags": ["AI/機械学習", "学習"],    // 階層化対応（/区切り）
    "pinned": false,                     // 機能7: ピン留め
    "updatedAt": 1703123456789
  },

  // タグメタデータ（シャード分割）
  "tagMeta:A": {
    "AI": { "color": null },
    "AI/機械学習": { "color": "#34a853" }
  },
  "tagMeta:学": {
    "学習": { "color": "#4285f4" }
  },

  // マイグレーションバージョン
  "_migrationVersion": 2
}
```

### データ構造の変更点

| 項目 | 旧 | 新 | 理由 |
|------|-----|-----|------|
| `project.name` | 常に空文字 | DOMから取得 | 名前検索に必須 |
| `project.pinned` | なし | boolean | ピン留め機能 |
| `allTags` | 独立配列 | **廃止** | tagMetaから導出 |
| `tagMeta` | なし | シャード分割 | 色・階層情報を統合管理 |

---

## 実装順序

```
Phase 0 (基盤整備) - 必須・最優先
├── 0-1: マイグレーション戦略
├── 0-2: 階層区切り文字（/）
├── 0-3: プロジェクト名キャプチャ
├── 0-4: tagMetaシャーディング
├── 0-5: 構造化フィルター
└── 0-6: キャッシュ構造拡張

Phase 1 (タグ機能) - スキーマ依存
├── 機能1: タグ階層化
└── 機能2: タグ色分け

Phase 2 (UI機能) - 基盤完了後
├── 機能4: タグ常時表示（色分け反映）
├── 機能5: プロジェクト名検索
├── 機能6: タグなしプロジェクト表示
└── 機能7: お気に入り/ピン留め

Phase 3 (統計機能) - 最後
└── 機能3: タグ使用統計
```

---

## Phase 0: 基盤整備（必須・最優先）

### 0-1: マイグレーション戦略

**目的**: 既存データを破壊せず、新スキーマに安全に移行

```javascript
async function migrateDataIfNeeded() {
  const items = await chrome.storage.sync.get(null);

  // マイグレーション済みフラグ確認
  if (items._migrationVersion >= 2) return;

  // Step 1: allTags → tagMeta への移行
  if (items.allTags && !items.tagMeta) {
    const tagMeta = {};
    for (const tag of items.allTags) {
      tagMeta[tag] = { color: null };
    }
    await chrome.storage.sync.set({ tagMeta });
  }

  // Step 2: project.pinned のデフォルト値設定
  for (const [key, value] of Object.entries(items)) {
    if (key.startsWith('project:') && value.pinned === undefined) {
      value.pinned = false;
      await chrome.storage.sync.set({ [key]: value });
    }
  }

  // Step 3: マイグレーション完了フラグ
  await chrome.storage.sync.set({ _migrationVersion: 2 });

  // Step 4: allTagsは削除せず残す（フォールバック用）
}
```

**互換性レイヤー**:
```javascript
function getAllTagNames() {
  if (Object.keys(cache.tagMeta).length > 0) {
    return Object.keys(cache.tagMeta);
  }
  return cache.allTags || [];
}
```

### 0-2: 階層区切り文字

**区切り文字**: `/`（スラッシュ）- フォルダのメタファーで直感的

```javascript
const HIERARCHY_SEPARATOR = '/';

// 例: "AI/機械学習/深層学習"
function parseHierarchicalTag(tag) {
  return tag.split(HIERARCHY_SEPARATOR);
}

function getParentTag(tag) {
  const parts = tag.split(HIERARCHY_SEPARATOR);
  if (parts.length <= 1) return null;
  return parts.slice(0, -1).join(HIERARCHY_SEPARATOR);
}
```

**validateTagName()の更新（319-331行）**:
```javascript
function validateTagName(tag) {
  if (tag.includes('/') && tag.split('/').some(p => !p.trim())) {
    return { valid: false, error: '階層区切り(/)の前後に空白は使えません' };
  }
  // ...
}
```

### 0-3: プロジェクト名キャプチャ

**取得タイミング**:
1. `injectFolderIcon()` 実行時（初回）
2. `showTagPopover()` 表示時（更新確認）

```javascript
function getProjectNameFromDOM(projectId) {
  const emojiEl = document.getElementById(`project-${projectId}-emoji`);
  if (!emojiEl) return '';

  const card = emojiEl.closest('mat-card.project-button-card');
  if (!card) return '';

  const titleEl = card.querySelector(
    '.project-button-title, .mdc-card__title, [data-testid="project-title"]'
  );
  return titleEl?.textContent?.trim() || '';
}

function syncProjectNameIfChanged(projectId) {
  const currentName = getProjectNameFromDOM(projectId);
  const cachedProject = getCachedProject(projectId);

  if (cachedProject && cachedProject.name !== currentName && currentName) {
    cachedProject.name = currentName;
    chrome.storage.sync.set({ [`project:${projectId}`]: cachedProject });
  }
}
```

### 0-4: tagMetaシャーディング

**問題**: 8KB/キー制限でtagMetaが肥大化

**解決策**: 頭文字でシャード分割

```javascript
// データ構造
{
  "tagMeta:A": { "AI": { color: null }, "AI/機械学習": { color: "#34a853" } },
  "tagMeta:学": { "学習": { color: "#4285f4" } },
  "tagMeta:_": { /* 記号・数字で始まるタグ */ }
}

async function loadTagMeta() {
  const items = await chrome.storage.sync.get(null);
  const tagMeta = {};
  for (const [key, value] of Object.entries(items)) {
    if (key.startsWith('tagMeta:')) {
      Object.assign(tagMeta, value);
    }
  }
  return tagMeta;
}

async function saveTagMeta(tagName, data) {
  const shardKey = `tagMeta:${getShardKey(tagName)}`;
  const shard = await chrome.storage.sync.get(shardKey);
  shard[shardKey] = shard[shardKey] || {};
  shard[shardKey][tagName] = data;
  await chrome.storage.sync.set(shard);
}

function getShardKey(tagName) {
  const firstChar = tagName.charAt(0).toUpperCase();
  if (/[A-Z]/.test(firstChar)) return firstChar;
  if (/[あ-ん]/.test(firstChar)) return 'あ';
  if (/[ア-ン]/.test(firstChar)) return 'ア';
  if (/[一-龥]/.test(firstChar)) return firstChar;
  return '_';
}
```

### 0-5: 構造化フィルター

**フィルターデータモデル**:
```javascript
const FilterType = {
  TAG: 'tag',
  TAG_PARENT: 'tagParent',
  UNTAGGED: 'untagged',
  TEXT: 'text',
  PINNED: 'pinned'
};

let currentFilters = [];
```

**applyFilters()実装**:
```javascript
function applyFilters() {
  const cards = originalCardOrder.length > 0
    ? originalCardOrder
    : Array.from(getProjectCards());

  cards.forEach(card => {
    const projectId = extractProjectIdFromCard(card);
    const project = getCachedProject(projectId);
    const gridItem = card.closest('project-button') || card;

    const visible = currentFilters.every(filter => {
      switch (filter.type) {
        case 'tag':
          return project?.tags?.includes(filter.value);
        case 'tagParent':
          return project?.tags?.some(t =>
            t === filter.value || t.startsWith(filter.value + '/')
          );
        case 'untagged':
          return !project?.tags?.length;
        case 'text':
          return project?.name?.toLowerCase().includes(filter.value.toLowerCase());
        case 'pinned':
          return project?.pinned === true;
        default:
          return true;
      }
    });

    gridItem.style.display = visible ? '' : 'none';
  });

  sortProjects(currentSortType);
}
```

**削除時の子タグ伝播**:
```javascript
async function removeTagFromAllProjects(tagToRemove) {
  const allTags = getAllTagNames();
  const childTags = allTags.filter(t => t.startsWith(tagToRemove + '/'));

  if (childTags.length > 0) {
    const confirmed = confirm(
      `「${tagToRemove}」を削除すると、子タグ（${childTags.length}個）も削除されます。続行しますか？`
    );
    if (!confirmed) return false;
  }

  const tagsToRemove = [tagToRemove, ...childTags];
  // ...削除処理
}
```

### 0-6: キャッシュ構造拡張

**変更箇所（33-37行）**:
```javascript
const cache = {
  tagMeta: {},
  projects: new Map(),
  initialized: false,
  migrationDone: false
};
```

**initCache()拡張（47-86行）**:
```javascript
async function initCache() {
  await migrateDataIfNeeded();
  cache.tagMeta = await loadTagMeta();
  // 既存のprojects読み込み処理...
}
```

---

## Phase 1: タグ機能

### 機能1: タグ階層化

**仕様**:
- 区切り文字: `/`
- 例: `AI/機械学習/深層学習`
- 親タグ自動作成: 「AI/機械学習」追加時に「AI」も自動作成
- フィルター: 親タグ選択時は子も含める
- 色継承: 子タグは親の色を継承

**実装**:
1. `validateTagName()` (319行): `/`記法の検証
2. `normalizeAllTags()` (338行): 階層順ソート
3. `ensureParentTagExists()`: 親タグ自動作成
4. `getChildTags()`, `getTagDepth()`: 階層操作関数
5. `renderTagList()` (1291行): ツリービュー表示
6. CSS: `.nf-tag-tree-item`, `.nf-tag-indent-N`

### 機能2: タグ色分け

**実装**:
1. `getTagColor(tagName)`: tagMetaから色取得
2. `setTagColor(tagName, color)`: 色設定
3. `showColorPicker(tagName, anchor)`: カラーピッカーUI
4. `createTagBadge()` (534行): 背景色適用
5. CSS: `.nf-color-picker`, `.nf-color-swatch`

**カラーパレット**: 8色（Google Material準拠）

---

## Phase 2: UI機能

### 機能4: タグ常時表示

1. `injectFolderIcon()` (845行): バッジコンテナ追加
2. `createInlineBadges(projectId, max=3)`: バッジ生成
3. `updateInlineBadges(projectId)`: バッジ更新
4. MutationObserver拡張
5. CSS: `.nf-inline-badges`, `.nf-inline-badge`

### 機能5: プロジェクト名検索

1. `injectFilterUI()` (1456行): 検索入力欄追加
2. `applyFilters()`: `{ type: 'text', value }` 対応
3. `debounce()`: 300ms
4. CSS: `.nf-search-input`

### 機能6: タグなしプロジェクト表示

1. `showTagDropdown()` (1259行): 「タグなし」オプション追加
2. `applyFilters()`: `{ type: 'untagged' }` 対応

### 機能7: お気に入り/ピン留め

1. `injectFolderIcon()` (845行): ★アイコン追加
2. `togglePinProject(projectId)`: トグル処理
3. `sortProjects()` (1055行): ピン留め優先ソート
4. CSS: `.nf-pin-icon`, `.nf-pin-icon.pinned`

---

## Phase 3: 統計機能

### 機能3: タグ使用統計（遅延計算）

```javascript
function calculateTagStatistics() {
  const stats = {};
  for (const [id, project] of cache.projects) {
    for (const tag of project.tags) {
      stats[tag] = (stats[tag] || 0) + 1;
    }
  }
  return stats;
}
```

1. popup.html: 統計セクション追加
2. popup.js: 統計表示ロジック

---

## 修正対象ファイル

| ファイル | Phase | 変更内容 |
|----------|-------|----------|
| `content/content.js` | 0-3 | キャッシュ拡張、マイグレーション、全機能ロジック |
| `content/content.css` | 1-2 | 階層表示、色分け、バッジ、ピンアイコン |
| `popup/popup.html` | 3 | 統計セクション追加 |
| `popup/popup.js` | 3 | 統計計算・表示ロジック |

---

## 注意事項

- **後方互換性**: マイグレーション処理で旧データを自動変換
- **ストレージ**: 全機能追加後も約70KB（上限102KB以内）
- **XSS対策**: 全てtextContentで表示（innerHTML禁止）
- **lastErrorチェック**: 全storage操作で実施
- **階層タグ仕様**: 親タグ自動作成、フィルター時は子を含む
- **区切り文字**: `/`（フォルダのメタファー）

---

## 参照ドキュメント

- `CLAUDE.md`: プロジェクト指示書
- `TAKEOVER.md`: 引き継ぎドキュメント
- `実装計画.md`: 既存の実装計画
- `アーキテクチャ.md`: システム設計

---

**最終更新**: 2025-12-30
**レビュー**: Codex MCP（3回レビュー済み、P0/P1問題なし）
