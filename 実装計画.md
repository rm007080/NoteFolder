# 詳細実装計画：NoteFolder（v4 - Content Script版）

> **更新履歴**:
> - 2025-12-26 v2: Codexレビューに基づき重大な問題を修正
> - 2025-12-26 v3: Codex再レビューに基づきAPI呼び出しとエラーハンドリングを修正
> - 2025-12-27 v4: 要件変更 - プロジェクト一覧ページでのContent Script方式に変更

---

## 0. v4 変更サマリ

### 要件変更の概要

| 項目 | v3以前 | v4（今回） |
|------|--------|-----------|
| 対象ページ | 個別プロジェクトページ `/notebook/{id}` | **プロジェクト一覧ページ** `https://notebooklm.google.com/` |
| UI方式 | ポップアップ内で操作 | **Content Script**でページに直接UIを注入 |
| タグ付け方法 | ポップアップでタグ入力 | 各プロジェクトの**フォルダアイコン**をクリック |
| フィルター | 同一タグのプロジェクト一覧表示 | **タグでプロジェクト一覧をフィルタリング** |
| ソート | なし | **名前順等でソート可能** |

### 新機能

1. **フォルダアイコン注入**: 各プロジェクトの絵文字アイコン右隣にフォルダアイコンを追加
2. **タグ入力ポップオーバー**: フォルダアイコンクリックでタグ入力UI表示
3. **タグフィルター**: 「最近のノートブック」ヘッダー付近にフィルターUI配置
4. **ソート機能**: フィルター後のプロジェクトを名前順等でソート

---

## 1. 技術仕様

### 1.1 Manifest V3 設定（Content Script追加）

```json
{
  "manifest_version": 3,
  "name": "NoteFolder",
  "version": "1.0.0",
  "description": "NotebookLMのプロジェクトをタグで管理する",
  "permissions": ["storage"],
  "host_permissions": ["https://notebooklm.google.com/*"],
  "content_scripts": [
    {
      "matches": ["https://notebooklm.google.com/*"],
      "js": ["content/content.js"],
      "css": ["content/content.css"],
      "run_at": "document_idle"
    }
  ],
  "action": {
    "default_popup": "popup/popup.html",
    "default_icon": {
      "16": "icons/icon16.png",
      "48": "icons/icon48.png",
      "128": "icons/icon128.png"
    }
  },
  "icons": {
    "16": "icons/icon16.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  }
}
```

### 1.2 権限の根拠

| 権限 | 理由 | 備考 |
|------|------|------|
| `storage` | `chrome.storage.sync` でタグデータを保存・同期 | |
| `host_permissions` | NotebookLMドメインでContent Script実行 | |
| ~~`tabs`~~ | 不要（Content Scriptが直接DOM操作） | v4で削除 |
| ~~`activeTab`~~ | 不要（Content Scriptが直接DOM操作） | v4で削除 |

---

## 2. データ構造設計

### 2.1 ストレージスキーマ（個別キー方式）

```javascript
// 保存形式（chrome.storage.sync）
{
  // プロジェクトごとに個別キー（8KB制限を回避）
  "project:955c465a-0662-41c0-ac1a-48e1c71d1837": {
    "id": "955c465a-0662-41c0-ac1a-48e1c71d1837",
    "name": "プロジェクト名（任意）",
    "tags": ["AI", "学習"],
    "updatedAt": 1703123456789
  },
  "project:xyz789-ghi012-abc345": {
    "id": "xyz789-ghi012-abc345",
    "name": "別のプロジェクト",
    "tags": ["リサーチ"],
    "updatedAt": 1703123456000
  },

  // 使用済みタグ一覧（入力候補用・ソート済み）
  "allTags": ["AI", "リサーチ", "仕事", "個人", "学習"]
}
```

### 2.2 プロジェクトID抽出ロジック

NotebookLMのプロジェクト一覧ページでは、各プロジェクトの絵文字アイコンに以下の形式でIDが含まれる：

```html
<div id="project-955c465a-0662-41c0-ac1a-48e1c71d1837-emoji">📘</div>
```

**抽出関数**:

```javascript
function extractProjectIdFromElement(element) {
  // id="project-{uuid}-emoji" から {uuid} を抽出
  const emojiElement = element.querySelector('[id^="project-"][id$="-emoji"]');
  if (!emojiElement) return null;

  const id = emojiElement.id;
  const match = id.match(/^project-(.+)-emoji$/);
  return match ? match[1] : null;
}
```

### 2.3 sync storage制限と対策

| 制約 | 値 | 対策 |
|------|----|----|
| 総容量 | 約102KB | 個別キー方式で分散保存 |
| 1アイテム上限 | 8,192バイト | 1プロジェクト = 1キーで確実に回避 |
| キー数上限 | 512個 | 約500プロジェクトまで対応可能 |
| 書き込み頻度 | 最大120回/分 | 変更分のみ書き込みで軽減 |

---

## 3. ファイル構成と役割

```
NoteFolder/
├── manifest.json              # Manifest V3定義（Content Script設定含む）
├── content/
│   ├── content.js             # メインロジック（UI注入・タグ操作・フィルター）
│   └── content.css            # 注入UIのスタイル
├── popup/
│   ├── popup.html             # 設定画面（将来拡張用）
│   ├── popup.css              # 設定画面スタイル
│   └── popup.js               # 設定画面ロジック
├── icons/
│   ├── icon16.png
│   ├── icon48.png
│   └── icon128.png
├── 要件定義.md
├── 実装計画.md                # このファイル
├── アーキテクチャ.md
├── 参照ルール.md
└── CLAUDE.md
```

### 各ファイルの責務

| ファイル | 責務 |
|----------|------|
| `manifest.json` | 権限・Content Script・popup・アイコン定義 |
| `content/content.js` | ① フォルダアイコン注入<br>② タグ入力ポップオーバー<br>③ タグ保存/読込<br>④ フィルター・ソートUI<br>⑤ プロジェクト表示/非表示制御 |
| `content/content.css` | 注入UIのスタイリング（フォルダアイコン、ポップオーバー、フィルターUI） |
| `popup/popup.html` | 設定画面（全タグ一覧表示、タグ削除など将来拡張用） |

---

## 4. 主要処理フロー

### 4.1 Content Script初期化

```
ページ読み込み完了（document_idle）
    ↓
initNoteFolder() 実行
    ↓
MutationObserver 設定（動的コンテンツ対応）
    ↓
既存のプロジェクト要素を検出
    ↓
各プロジェクトにフォルダアイコンを注入
    ↓
「最近のノートブック」ヘッダーを検出
    ↓
フィルター・ソートUIを注入
    ↓
chrome.storage.sync から全プロジェクトのタグを読み込み
    ↓
タグ付きプロジェクトにインジケーター表示
```

### 4.2 フォルダアイコン注入フロー

```javascript
function injectFolderIcon(projectElement) {
  // すでに注入済みならスキップ
  if (projectElement.querySelector('.nf-folder-icon')) return;

  // プロジェクトIDを抽出
  const projectId = extractProjectIdFromElement(projectElement);
  if (!projectId) return;

  // 絵文字アイコン要素を取得
  const emojiElement = projectElement.querySelector('[id$="-emoji"]');
  if (!emojiElement) return;

  // フォルダアイコンを作成
  const folderIcon = document.createElement('button');
  folderIcon.className = 'nf-folder-icon';
  folderIcon.innerHTML = '📁';  // または SVGアイコン
  folderIcon.setAttribute('data-project-id', projectId);
  folderIcon.setAttribute('aria-label', 'タグを管理');

  // 絵文字アイコンの右隣に挿入
  emojiElement.parentNode.insertBefore(folderIcon, emojiElement.nextSibling);

  // クリックイベント
  folderIcon.addEventListener('click', (e) => {
    e.stopPropagation();  // プロジェクトを開かないようにする
    showTagPopover(folderIcon, projectId);
  });
}
```

### 4.3 タグ入力ポップオーバーフロー

```
フォルダアイコンをクリック
    ↓
showTagPopover(targetElement, projectId) 実行
    ↓
chrome.storage.sync.get でプロジェクトのタグと allTags を取得
    ↓
ポップオーバーUIを作成・表示
    ├── 現在のタグ一覧（削除可能）
    ├── タグ入力欄
    └── 候補リスト（allTags から前方一致）
    ↓
タグ追加/削除時
    ↓
chrome.storage.sync.set で保存（エラーハンドリング付き）
    ↓
UI更新（タグバッジ、インジケーター）
```

### 4.4 タグ追加処理

```javascript
async function addTagToProject(projectId, newTag) {
  // バリデーション
  const validation = validateTagName(newTag);
  if (!validation.valid) {
    showToast(validation.error);
    return false;
  }

  const normalizedTag = validation.tag;

  return new Promise((resolve) => {
    chrome.storage.sync.get(
      { [`project:${projectId}`]: null, allTags: [] },
      (result) => {
        if (chrome.runtime.lastError) {
          showToast('データの読み込みに失敗しました');
          resolve(false);
          return;
        }

        // プロジェクトデータを作成または更新
        const project = result[`project:${projectId}`] || {
          id: projectId,
          name: '',
          tags: [],
          updatedAt: Date.now()
        };

        // 重複チェック
        if (project.tags.includes(normalizedTag)) {
          showToast('このタグは既に追加されています');
          resolve(false);
          return;
        }

        // タグ追加
        project.tags.push(normalizedTag);
        project.updatedAt = Date.now();

        // allTags更新
        let allTags = [...result.allTags, normalizedTag];
        allTags = normalizeAllTags(allTags);

        // 保存
        chrome.storage.sync.set(
          { [`project:${projectId}`]: project, allTags: allTags },
          () => {
            if (chrome.runtime.lastError) {
              showToast('タグの追加に失敗しました');
              resolve(false);
              return;
            }
            resolve(true);
          }
        );
      }
    );
  });
}
```

### 4.5 フィルター・ソートUIフロー

```
「最近のノートブック」ヘッダーを検出
    ↓
フィルター・ソートUIを注入
    ┌───────────────────────────────────────────────┐
    │ タグでフィルター: [▼ タグを選択]  ソート: [▼ 更新日時] │
    │ 選択中: [AI ×] [学習 ×]              [クリア]      │
    └───────────────────────────────────────────────┘
    ↓
タグ選択時
    ↓
filterProjectsByTags(selectedTags) 実行
    ↓
各プロジェクト要素に対して:
    ├── タグが一致 → display: '' (表示)
    └── タグが不一致 → display: 'none' (非表示)
    ↓
ソート選択時
    ↓
sortProjects(sortType) 実行
    ↓
DOMの並び順を変更
```

### 4.6 プロジェクトフィルタリング処理

```javascript
function filterProjectsByTags(selectedTags) {
  if (selectedTags.length === 0) {
    // フィルターなし: 全プロジェクト表示
    document.querySelectorAll('.project-button-box').forEach(el => {
      el.style.display = '';
    });
    return;
  }

  // ストレージから全プロジェクトのタグを取得
  chrome.storage.sync.get(null, (items) => {
    if (chrome.runtime.lastError) return;

    const projectTags = {};
    for (const [key, value] of Object.entries(items)) {
      if (key.startsWith('project:')) {
        projectTags[value.id] = value.tags || [];
      }
    }

    // 各プロジェクト要素の表示/非表示を制御
    document.querySelectorAll('.project-button-box').forEach(el => {
      const projectId = extractProjectIdFromElement(el);
      if (!projectId) return;

      const tags = projectTags[projectId] || [];

      // 選択されたタグのいずれかを持っているか
      const hasMatchingTag = selectedTags.some(tag => tags.includes(tag));

      el.style.display = hasMatchingTag ? '' : 'none';
    });
  });
}
```

---

## 5. UI設計

### 5.1 フォルダアイコン

```
プロジェクト一覧の各項目:
┌─────────────────────────────────────────┐
│ [📘][📁] プロジェクト名                   │
│  ↑   ↑                                  │
│  │   └── NoteFolder注入アイコン（クリック可能）
│  └────── 元の絵文字アイコン               │
└─────────────────────────────────────────┘
```

### 5.2 タグ入力ポップオーバー

```
┌─────────────────────────────────┐
│ タグを管理                    [×] │
├─────────────────────────────────┤
│ 現在のタグ:                      │
│ [AI ×] [学習 ×]                  │
├─────────────────────────────────┤
│ タグを追加:                      │
│ ┌─────────────────────┐ [追加]  │
│ │ 入力...             │         │
│ └─────────────────────┘         │
│ ┌─────────────────────┐         │
│ │ リサーチ（候補）     │         │
│ │ 読書（候補）         │         │
│ └─────────────────────┘         │
└─────────────────────────────────┘
```

### 5.3 フィルター・ソートUI

```
「最近のノートブック」ヘッダーの下:
┌─────────────────────────────────────────────────────────┐
│ 🏷️ タグでフィルター: [▼ タグを選択]  📊 ソート: [▼ 更新日時] │
│ 選択中: [AI ×] [学習 ×]                        [クリア]  │
└─────────────────────────────────────────────────────────┘
```

### 5.4 タグインジケーター

タグが付いているプロジェクトには、フォルダアイコンにインジケーターを表示：

```
タグなし: 📁 (グレー)
タグあり: 📁• (アクセントカラー + ドット)
```

---

## 6. セキュリティ対策

### 6.1 XSS対策（必須）

```javascript
// ❌ 絶対禁止
element.innerHTML = tagName;

// ✅ 必須: textContentを使用
element.textContent = tagName;

// ✅ または createElement + appendChild
function createTagBadge(tagName, onRemove) {
  const badge = document.createElement('span');
  badge.className = 'nf-tag-badge';
  badge.textContent = tagName;

  const removeBtn = document.createElement('button');
  removeBtn.textContent = '×';
  removeBtn.addEventListener('click', onRemove);

  badge.appendChild(removeBtn);
  return badge;
}
```

### 6.2 入力バリデーション

```javascript
function validateTagName(tag) {
  if (!tag || !tag.trim()) {
    return { valid: false, error: 'タグ名を入力してください' };
  }

  if (tag.length > 50) {
    return { valid: false, error: 'タグ名は50文字以内にしてください' };
  }

  return { valid: true, tag: tag.trim() };
}
```

### 6.3 ストレージ操作のエラーハンドリング

```javascript
// 全storage操作でlastErrorをチェック
chrome.storage.sync.get(defaults, (result) => {
  if (chrome.runtime.lastError) {
    console.error('Storage read error:', chrome.runtime.lastError.message);
    showToast('データの読み込みに失敗しました');
    return;
  }
  // 正常時の処理
});

chrome.storage.sync.set(data, () => {
  if (chrome.runtime.lastError) {
    console.error('Storage write error:', chrome.runtime.lastError.message);
    showToast('データの保存に失敗しました');
    return;
  }
  // 正常時の処理
});
```

---

## 7. ストレージ操作のベストプラクティス

### 7.1 正しいAPIシグネチャ

```javascript
// 第1引数: デフォルト値オブジェクト
// 第2引数: コールバック関数
chrome.storage.sync.get(
  {
    [`project:${projectId}`]: null,
    allTags: []
  },
  (result) => {
    // result にはデフォルト値またはストレージの値が入る
  }
);
```

### 7.2 allTagsの正規化

```javascript
function normalizeAllTags(allTags) {
  return [...new Set(allTags)]
    .filter(tag => tag && tag.trim())
    .sort((a, b) => a.localeCompare(b, 'ja'));
}
```

---

## 8. 動的コンテンツ対応

NotebookLMはSPAのため、MutationObserverで動的に追加される要素を監視：

```javascript
function observeProjectList() {
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          // 新しく追加されたプロジェクト要素を検出
          const projectElements = node.querySelectorAll
            ? node.querySelectorAll('[id^="project-"][id$="-emoji"]')
            : [];

          projectElements.forEach((el) => {
            const projectBox = el.closest('.project-button-box');
            if (projectBox) {
              injectFolderIcon(projectBox);
            }
          });

          // 自身がプロジェクト要素の場合
          if (node.id && node.id.match(/^project-.+-emoji$/)) {
            const projectBox = node.closest('.project-button-box');
            if (projectBox) {
              injectFolderIcon(projectBox);
            }
          }
        }
      });
    });
  });

  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
}
```

---

## 9. 実装順序（ステップ）

| ステップ | 内容 | 確認ポイント |
|----------|------|--------------|
| **Step 1** | `manifest.json` 更新（Content Script設定） | Content Scriptが読み込まれるか |
| **Step 2** | `content/content.js` 基本構造 + フォルダアイコン注入 | プロジェクト一覧にアイコンが表示されるか |
| **Step 3** | タグ入力ポップオーバー実装 | ポップオーバーが表示・操作できるか |
| **Step 4** | タグ保存・読込（chrome.storage.sync） | タグがストレージに保存・復元されるか |
| **Step 5** | フィルターUI実装 | タグでプロジェクトがフィルタリングされるか |
| **Step 6** | ソート機能実装 | プロジェクトがソートされるか |
| **Step 7** | MutationObserver実装 | 動的に追加されたプロジェクトにも対応できるか |
| **Step 8** | スタイリング + UX改善 | 使いやすいUIか |

---

## 10. 開発・デバッグ手順

```bash
# 1. Chromeで読み込み
#    chrome://extensions → デベロッパーモード ON
#    「パッケージ化されていない拡張機能を読み込む」→ フォルダ選択

# 2. コード変更後
#    chrome://extensions → 「更新」ボタンをクリック
#    NotebookLMページをリロード

# 3. Content Scriptのデバッグ
#    NotebookLMページで F12 → Console
#    Content Scriptのログが表示される

# 4. Storage確認
#    DevTools → Application → Storage → Extension Storage

# 5. 要素検査
#    DevTools → Elements で注入されたUIを確認
```

---

## 11. テストチェックリスト

### 機能テスト

- [ ] プロジェクト一覧ページでフォルダアイコンが表示される
- [ ] フォルダアイコンクリックでポップオーバーが表示される
- [ ] タグ追加が正常に動作する
- [ ] タグ削除が正常に動作する
- [ ] タグ候補が表示される
- [ ] タグでプロジェクトがフィルタリングされる
- [ ] ソートが正常に動作する
- [ ] ページ遷移後も動作する（MutationObserver）

### セキュリティテスト

- [ ] `<script>alert(1)</script>` をタグ名として入力 → XSSが発生しない

### 境界値テスト

- [ ] 空のタグ名 → 追加されない
- [ ] 重複タグ → 追加されない（または警告）
- [ ] 50文字超のタグ名 → エラー表示
- [ ] 特殊文字（絵文字、記号）→ 正常に保存・表示される

### エラーハンドリングテスト

- [ ] ストレージ読み込み失敗時 → エラーメッセージが表示される
- [ ] ストレージ書き込み失敗時 → エラーメッセージが表示される

---

## 12. 既知の制限事項

| 制限 | 影響 | 将来的な対応案 |
|------|------|----------------|
| 最大500プロジェクト | sync storageのキー数上限 | chrome.storage.local への移行検討 |
| NotebookLMのDOM構造依存 | サイト更新で動作しなくなる可能性 | セレクタを設定可能にする |
| プロジェクト名取得なし | フィルター結果の識別が困難 | DOMからプロジェクト名も取得 |

---

## 次のステップ

この修正版計画で問題なければ、以下の順で実装を進めます。

1. **Step 1**: `manifest.json` 更新（Content Script設定）
2. **Step 2**: `content/content.js` + `content/content.css` 作成（フォルダアイコン注入）
3. **Step 3-8**: 段階的に機能追加
