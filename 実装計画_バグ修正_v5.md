# NoteFolder バグ修正実装計画 v5

## 対象ファイル
- `/mnt/c/Users/littl/app-dev/06_NoteFolder/NoteFolder/content/content.js`

---

## Phase 1: セクション切り替え後のフィルター無効化修正

### 問題
`setupSectionToggleListener()`がリスナーを重複登録し、`originalCardOrder`が古いDOM参照を保持したままになる。

### Codexレビュー指摘
- 単純フラグだと「新しいtoggleGroupにはリスナーが付かない」可能性がある
- 要素単位で`dataset`を使用が安全
- `originalCardOrder`リセット後に`saveOriginalCardOrder()`を再実行する設計が必要
- `applyFilters()`を再実行しないとフィルターが効いていないように見える

### 修正内容

#### 1-1. setupSectionToggleListener関数を修正（3536-3564行）

要素単位で`dataset`を使用してリスナー重複を防止:

```javascript
function setupSectionToggleListener() {
  const toggleGroup = document.querySelector('mat-button-toggle-group.project-section-toggle');
  if (!toggleGroup) {
    setTimeout(setupSectionToggleListener, 1000);
    return;
  }

  // 要素単位でリスナー設定済みかチェック
  if (toggleGroup.dataset.nfListenerAttached) return;
  toggleGroup.dataset.nfListenerAttached = 'true';

  toggleGroup.addEventListener('click', () => {
    // DOM参照をリセット
    originalCardOrder = [];

    setTimeout(() => {
      saveOriginalCardOrder(true);  // 強制更新
      injectAllFolderIcons();
      for (const [projectId] of cache.projects) {
        updateFolderIconState(projectId);
      }
      applyFilters();  // フィルター再適用
    }, 300);

    setTimeout(() => {
      saveOriginalCardOrder(true);
      injectAllFolderIcons();
      for (const [projectId] of cache.projects) {
        updateFolderIconState(projectId);
      }
      applyFilters();
    }, 800);
  }, { capture: true });
}
```

#### 1-2. saveOriginalCardOrder関数に強制更新オプションを追加（2394-2402行）

```javascript
function saveOriginalCardOrder(force = false) {
  const cards = Array.from(getProjectCards());
  if (cards.length > 0 && (force || originalCardOrder.length === 0)) {
    originalCardOrder = cards;
  }
}
```

#### 1-3. toggleGroup差し替え検知用のMutationObserver追加（SPAナビゲーション対応）

`setupSPANavigationListener`内で、toggleGroup差し替えを検知:

```javascript
const observer = new MutationObserver((mutations) => {
  for (const mutation of mutations) {
    if (mutation.type === 'childList') {
      // toggleGroupが再生成された場合、リスナーを再設定
      const newToggleGroup = document.querySelector('mat-button-toggle-group.project-section-toggle');
      if (newToggleGroup && !newToggleGroup.dataset.nfListenerAttached) {
        setupSectionToggleListener();
      }
    }
  }
});
```

---

## Phase 2: タグポップオーバーでの親子関係D&D実装

### 問題
子タグセクション（`nf-popover-child-tags`）にD&D処理が未実装のため、子タグを親タグにドラッグしても何も起きない。

### Codexレビュー指摘
- `draggedParent`は親タグのdragstartでしかセットされないため、子タグにdraggableを付けるだけでは親タグ側のdragoverが反応しない
- `dataTransfer`には必ずフルパスのタグ名を入れる必要がある
- 専用MIME（`application/x-nf-tag`）を使い、dragoverではdataTransfer.typesで受け入れ判定する設計が親/子共通化に有効

### 修正内容

#### 2-1. 親タグバッジのdragstartを統一MIMEに変更（1851-1857行付近）

```javascript
badge.addEventListener('dragstart', (e) => {
  draggedParent = parentName;
  badge.classList.add('nf-dragging');
  parentSection.classList.add('nf-dragging-active');
  e.dataTransfer.setData('text/plain', parentName);
  e.dataTransfer.setData('application/x-nf-tag', parentName);  // 統一MIME追加
  e.dataTransfer.effectAllowed = 'move';
});
```

#### 2-2. 親タグバッジのdragover/dropを修正（1869-1898行付近）

`dataTransfer.types`で`application/x-nf-tag`をチェックして受け入れ判定:

```javascript
badge.addEventListener('dragover', (e) => {
  e.preventDefault();
  // 統一MIMEで判定（親/子両方対応）
  if (e.dataTransfer.types.includes('application/x-nf-tag')) {
    // 自分自身以外ならドロップ可能
    e.dataTransfer.dropEffect = 'link';
    badge.classList.add('nf-parent-drop-target');
  }
});

badge.addEventListener('dragleave', () => {
  badge.classList.remove('nf-parent-drop-target');
});

badge.addEventListener('drop', async (e) => {
  e.preventDefault();
  e.stopPropagation();
  badge.classList.remove('nf-parent-drop-target');

  const dragged = e.dataTransfer.getData('text/plain');
  if (dragged && dragged !== parentName) {
    // 循環参照防止
    if (parentName.startsWith(dragged + HIERARCHY_SEPARATOR)) {
      showToast('子タグの中には移動できません');
      return;
    }
    const success = await moveTagToParent(dragged, parentName);
    if (success) {
      updateUI();
      for (const [projId] of cache.projects) {
        updateInlineBadges(projId);
      }
    }
  }
});
```

#### 2-3. 子タグバッジにD&D属性とイベントを追加（1921-1943行付近）

`childTags.forEach`内で、badge作成後に追加:

```javascript
badge.setAttribute('draggable', 'true');
badge.setAttribute('data-full-tag', tag);

badge.addEventListener('dragstart', (e) => {
  badge.classList.add('nf-dragging');
  e.dataTransfer.setData('text/plain', tag);  // フルパス
  e.dataTransfer.setData('application/x-nf-tag', tag);  // 統一MIME
  e.dataTransfer.effectAllowed = 'move';
});

badge.addEventListener('dragend', () => {
  badge.classList.remove('nf-dragging');
  document.querySelectorAll('.nf-parent-drop-target').forEach(el => {
    el.classList.remove('nf-parent-drop-target');
  });
});
```

---

## Phase 3: 同名タグ統合機能の実装

### 問題
`moveTagToParent()`の重複チェック（1314-1317行）が厳密すぎて、同名タグの統合ができない。

### Codexレビュー指摘
- `renameTagInAllProjects`を流用すると既存タグの`tagMeta`を上書きしてしまう
- プロジェクト側のタグ配列に重複が発生するため、Set化と`normalizeAllTags`の再適用が必要
- 全タグ/全プロジェクトを一括更新できる設計がクォータ面で安全
- 子孫リストを先にスナップショット化しないと取りこぼす可能性がある
- 統合後にフィルター状態を更新しないとselectedFilterTagsが消えたタグを指し続ける

### ユーザー仕様
- 同名タグが存在する場合は**自動統合**（確認ダイアログなし）
- 移動元タグのプロジェクト紐付けを既存タグに統合
- 移動元タグは削除
- 色情報: **欠損補完**（targetが無色の場合のみsourceの色を引き継ぐ）
- フィルター: **targetに置換して維持**

### 修正内容

#### 3-1. タグ統合関数を新規作成（1278行付近、moveTagToParent直前に追加）

```javascript
/**
 * タグを統合する（sourceTagの紐付けをtargetTagに移動し、sourceTagを削除）
 * @param {string} sourceTag - 統合元タグ（削除される）
 * @param {string} targetTag - 統合先タグ（残る）
 * @returns {Promise<boolean>}
 */
async function mergeTagsInAllProjects(sourceTag, targetTag) {
  if (sourceTag === targetTag) return false;

  // 0. 子孫リストを先にスナップショット化（メタ削除前に取得）
  const allTags = getAllTagNames();
  const childTags = allTags.filter(t => t.startsWith(sourceTag + HIERARCHY_SEPARATOR));

  const projectUpdates = {};
  const metaUpdates = {};

  // 1. 全プロジェクトでsourceTagをtargetTagに置換
  for (const [projectId, project] of cache.projects) {
    if (project.tags && project.tags.includes(sourceTag)) {
      let updatedTags = [...project.tags];
      const sourceIndex = updatedTags.indexOf(sourceTag);

      if (updatedTags.includes(targetTag)) {
        // targetTagが既にある場合はsourceTagを削除
        updatedTags.splice(sourceIndex, 1);
      } else {
        // targetTagがない場合はsourceTagをtargetTagに置換
        updatedTags[sourceIndex] = targetTag;
      }

      // 重複除去（Set化）
      updatedTags = [...new Set(updatedTags)];

      project.tags = updatedTags;
      projectUpdates[`project:${projectId}`] = { ...project, updatedAt: Date.now() };
    }
  }

  // 2. tagMeta欠損補完（targetが無色の場合のみsourceの色を引き継ぐ）
  const sourceMeta = cache.tagMeta[sourceTag];
  const targetMeta = cache.tagMeta[targetTag];
  if (sourceMeta && sourceMeta.color && (!targetMeta || !targetMeta.color)) {
    metaUpdates[`tagMeta:${targetTag}`] = { color: sourceMeta.color };
    cache.tagMeta[targetTag] = { ...targetMeta, color: sourceMeta.color };
  }

  // 3. sourceTagのメタデータを削除対象に追加
  metaUpdates[`tagMeta:${sourceTag}`] = null;  // 削除用
  delete cache.tagMeta[sourceTag];

  // 4. sourceTagの子タグも再帰的に処理（スナップショットを使用）
  for (const childTag of childTags) {
    const suffix = childTag.substring(sourceTag.length);
    const newChildTag = targetTag + suffix;

    if (allTags.includes(newChildTag)) {
      await mergeTagsInAllProjects(childTag, newChildTag);
    } else {
      await renameTagInAllProjects(childTag, newChildTag);
    }
  }

  // 5. ストレージに一括保存（クォータ対策）
  const storageUpdates = { ...projectUpdates };
  for (const [key, value] of Object.entries(metaUpdates)) {
    if (value === null) {
      // 削除はchrome.storage.sync.removeで別途処理
      await new Promise(resolve => chrome.storage.sync.remove(key, resolve));
    } else {
      storageUpdates[key] = value;
    }
  }

  if (Object.keys(storageUpdates).length > 0) {
    await new Promise((resolve) => {
      chrome.storage.sync.set(storageUpdates, () => {
        if (chrome.runtime.lastError) {
          console.error('Tag merge error:', chrome.runtime.lastError.message);
        }
        resolve();
      });
    });
  }

  // 6. フィルター状態を更新（sourceをtargetに置換）
  if (selectedFilterTags.includes(sourceTag)) {
    const idx = selectedFilterTags.indexOf(sourceTag);
    if (!selectedFilterTags.includes(targetTag)) {
      selectedFilterTags[idx] = targetTag;
    } else {
      selectedFilterTags.splice(idx, 1);
    }
  }

  // 7. キャッシュの正規化
  cache.allTags = normalizeAllTags(getAllTagNames());

  return true;
}
```

#### 3-2. moveTagToParent関数の重複チェックを修正（1313-1317行）

```javascript
// 変更前:
if (allTags.includes(newTagName) && newTagName !== sourceTag) {
  showToast('同名のタグが既に存在します');
  return false;
}

// 変更後（自動統合）:
if (allTags.includes(newTagName) && newTagName !== sourceTag) {
  const success = await mergeTagsInAllProjects(sourceTag, newTagName);
  if (success) {
    showToast(`「${sourceBaseName}」を「${newTagName}」に統合しました`);
  }
  return success;
}
```

---

## 重要な行番号リファレンス

| 機能 | 行番号 |
|------|--------|
| 子タグセクション | 1908-1946 |
| moveTagToParent | 1279-1328 |
| renameTagInAllProjects | 1336-1376 |
| removeTagMeta | 320-343 |
| resetUIState | 2407-2413 |
| applyFilters | 2429-2481 |
| setupSectionToggleListener | 3536-3564 |
| setupSPANavigationListener | 3579-3612 |

---

## テスト項目

### Phase 1 テスト
- [ ] 「全て」タブでタグフィルターを適用
- [ ] 「マイノートブック」タブに切り替え
- [ ] 「全て」タブに戻り、タグフィルターが正常に動作することを確認
- [ ] 複数回のタブ切り替え後もフィルターが動作することを確認

### Phase 2 テスト
- [ ] ポップオーバーを開き、子タグを親タグにD&Dして親子関係が作成されることを確認
- [ ] 親タグを別の親タグにD&Dして親子関係が作成されることを確認
- [ ] D&D中のビジュアルフィードバック（dragging, drop-target）が表示されることを確認
- [ ] 循環参照（自分の子孫への移動）が防止されることを確認

### Phase 3 テスト
- [ ] 「歩行」タグと「健康/歩行」タグが存在する状態で、「歩行」を「健康」にD&D
- [ ] 統合後、「歩行」が紐付いていたプロジェクトが「健康/歩行」に移行されていることを確認
- [ ] 「歩行」タグが削除されていることを確認
- [ ] targetが無色でsourceに色がある場合、色が引き継がれることを確認
- [ ] フィルターでsourceを選択中だった場合、targetに置き換わることを確認

---

**最終更新**: 2025-12-31
**ステータス**: 実装準備完了
